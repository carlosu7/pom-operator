package io.github.pixee.maven.operator

import io.github.pixee.maven.operator.java.AbstractVersionCommandJ
import io.github.pixee.maven.operator.java.EmbedderFacadeJ
import io.github.pixee.maven.operator.java.IgnorableJ
import io.github.pixee.maven.operator.java.VersionDefinitionJ
import org.apache.maven.model.building.ModelBuildingException
import org.codehaus.plexus.util.xml.Xpp3Dom
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import java.util.*

/**
 * Queries Version Set in the POM by inspecting the effective pom generated by Embedder
 */
class UnwrapEffectivePom : AbstractVersionCommandJ() {
    override fun execute(pm: ProjectModel): Boolean =
        try {
            executeInternal(pm)
        } catch (e: Exception) {

            if (e is ModelBuildingException) {
                IgnorableJ.LOGGER.debug("mbe (you can ignore): ", e)
            } else {
                LOGGER.warn("While trying embedder: ", e)
            }
            false
        }

    fun executeInternal(pm: ProjectModel): Boolean {
        val embedderFacadeResponse = EmbedderFacadeJ.invokeEmbedder(
            EmbedderFacadeJ.EmbedderFacadeRequest(pm.offline, null,  pm.pomFile.file, null, null)
        )

        val definedVersions: MutableSet<VersionDefinitionJ> =
            TreeSet<VersionDefinitionJ>(AbstractVersionCommandJ.VERSION_KIND_COMPARATOR)

        val res = embedderFacadeResponse.modelBuildingResult

        listOf(
            res.effectiveModel.build.pluginManagement.plugins,
            res.effectiveModel.build.plugins,
        ).flatMap { it }.filter { p -> p.artifactId.equals("maven-compiler-plugin") }
            .mapNotNull { it.configuration }
            .filterIsInstance(Xpp3Dom::class.java)
            .map {
                val config = it as Xpp3Dom

                val definedOnes = AbstractVersionCommandJ.TYPE_TO_KIND.entries.mapNotNull {
                    val child = config.getChild(it.key)

                    if (null != child) {
                        VersionDefinitionJ(it.value, child.value)
                    } else {
                        null
                    }
                }.toList()

                definedVersions.addAll(definedOnes)
            }

        val definedProperties = res.effectiveModel.properties.mapNotNull {
            if (AbstractVersionCommandJ.PROPERTY_TO_KIND.containsKey(it.key as String)) {
                val kind = AbstractVersionCommandJ.PROPERTY_TO_KIND[it.key]!!

                VersionDefinitionJ(kind, it.value as String)
            } else {
                null
            }
        }.toList()

        definedVersions.addAll(definedProperties)

        this.result.addAll(definedVersions)

        return definedVersions.isNotEmpty()
    }

    companion object {
        val LOGGER: Logger = LoggerFactory.getLogger(UnwrapEffectivePom::class.java)
    }
}